name: Install OneClickInstall Docker

on:
  schedule:
    - cron: "00 20 * * 0"
  push:
    branches:
      - "hotfix/**"
      - "release/**"
      - "develop"
    paths:
      - ".github/workflows/ci-oci-docker-install.yml"
      - "install/OneClickInstall/install-Docker.sh"
      - "install/docker/*.yml"
  workflow_dispatch:
    inputs:
      testing:
        description: "Use 4testing images"
        required: true
        default: true
        type: boolean
      offline:
        description: "Publish 4testing offline archive"
        required: true
        default: false
        type: boolean

jobs:
  Install-OneClickInstall-Docker:
    runs-on: ubuntu-22.04
    steps:
      - name: Free Disk Space
        run: |
          sudo docker image prune --all --force
          sudo rm -rf /usr/local/lib/android || true

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Test OCI docker scripts
        run: |
          IS_4TESTING="${{ github.event.inputs.testing }}"
          wget https://raw.githubusercontent.com/${{ github.repository }}/${{ github.ref_name }}/install/OneClickInstall/install-Docker.sh
          sed -i "1i set -x" install-Docker.sh && sed -i "/docker-compose.*up -d/ s/$/ --quiet-pull/" install-Docker.sh
          sudo bash install-Docker.sh -skiphc true -noni true -gb ${{ github.ref_name }} $([ "${IS_4TESTING:-true}" != "false" ] && echo "-s 4testing-") || exit $?

          echo -n "Waiting for all containers to start..."
          timeout 300 bash -c 'while docker ps | grep -q "starting"; do sleep 5; done' && echo "OK" || echo "container_status=timeout" >> $GITHUB_ENV

      - name: Check container status
        run: |
          SERVICES=(dashboards db docspace ds fluent healthchecks identity notify opensearch proxy rabbitmq redis)
          for SERVICE in "${SERVICES[@]}"; do YML_ARGS+=( -f "/app/onlyoffice/${SERVICE}.yml" ); done
          for SVC in $(docker compose "${YML_ARGS[@]}" config --services); do
            docker compose "${YML_ARGS[@]}" ps "$SVC" | grep -q ${SVC} || { echo "::error::$SVC was not created"; MISSING_COUNT=$((MISSING_COUNT+1)); }
          done; [ "${MISSING_COUNT:=0}" -gt 0 ] && { echo "::error::$MISSING_COUNT service(s) were not created."; exit 1; }

          docker ps --all --format "{{.Names}}" | xargs -I {} sh -c '
              status=$(docker inspect --format="{{if .State.Health}}{{.State.Health.Status}}{{else}}no healthcheck{{end}}" {});
              case "$status" in
                healthy) color="\033[0;32m" ;;                                        # green
                "no healthcheck") color="\033[0;33m" ;;                               # yellow
                *) color="\033[0;31m"; echo "container_status=red" >> $GITHUB_ENV ;;  # red
              esac;
              printf "%-50s ${color}%s\033[0m\n" "{}:" "$status";
          '

      - name: Print logs for crashed container
        run: |
          docker ps --all --format "{{.Names}}" | xargs -I {} sh -c '
              status=$(docker inspect --format="{{if .State.Health}}{{.State.Health.Status}}{{else}}no healthcheck{{end}}" {});
              case "$status" in
                healthy | "no healthcheck") ;;
                *)
                  echo "Logs for container {}:";
                  docker logs --tail 30 {} | sed "s/^/\t/g";
                  ;;
              esac;
          '
          case "${{ env.container_status }}" in
              timeout) echo "::error:: Timeout reached. Not all containers are running."; exit 1 ;;
              red) echo "::error:: One or more containers have status 'red'. Job will fail."; exit 1 ;;
          esac

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref_name }}

      - name: "Checking Docker scripts for errors"
        run: |
          set -eux
          sudo apt-get install -y shellcheck
          find install/docker -type f -name "*.sh" | cat - <(echo "install/OneClickInstall/install-Docker.sh") \
            | xargs shellcheck --exclude="$(awk '!/^#|^$/ {print $1}' tests/lint/sc_ignore | paste -sd ",")" --severity=warning | tee sc_output
          awk '/\(warning\):/ {w++} /\(error\):/ {e++} END {if (w+e) printf "::warning ::ShellCheck detected %d warnings and %d errors\n", w+0, e+0}' sc_output

      - name: Free Disk Space
        if: ${{ success() && github.event.inputs.offline == 'true' }}
        run: |
          docker stop $(docker ps -a -q) && docker rm $(docker ps -a -q) && docker volume rm $(docker volume ls -q)
          curl -fsSL https://raw.githubusercontent.com/${{ github.repository }}/refs/heads/${{ github.ref_name }}/.github/scripts/free-disk-space-linux.sh | sudo CLEAN_DOCKER=0 bash

      - name: Creating 4testing offline self-extracting archive
        if: ${{ success() && github.event.inputs.offline == 'true' }}
        run: |
          INSTALL_PATH=${{ github.workspace }}/install
          IS_4TESTING="${{ github.event.inputs.testing }}"

          for repo in onlyoffice/$( [ "${IS_4TESTING:-true}" != "false" ] && echo 4testing- )documentserver{,-de}; do
            tag=$(curl -s "https://registry.hub.docker.com/v2/repositories/${repo}/tags?page_size=100" \
                  | jq -r '.results[].name' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+)?$' | sort -Vr | head -n1)
            [ -z "$tag" ] && exit 1
            docker pull "${repo}:${tag}"
          done

          docker images --format "{{.Repository}}:{{.Tag}}" | grep "4testing-" | xargs -I{} bash -c '
            docker tag "$1" $(echo "${1/4testing-/}" | sed -E "s/([0-9]+\.[0-9]+\.[0-9]+)\.[0-9]+/\1/")
            docker rmi "$1"
          ' _ {}

          sed -i 's~\(OFFLINE_INSTALLATION="\|SKIP_HARDWARE_CHECK="\).*"$~\1true"~' "${INSTALL_PATH}/OneClickInstall/install-Docker.sh"

          echo "Creating offline self-extracting archive..."
          docker save $(docker images --format "{{.Repository}}:{{.Tag}}" | grep -E 'onlyoffice/documentserver') | xz --verbose -T0 -z -9e > ${INSTALL_PATH}/docs_images.tar.xz
          docker rmi $(docker images --format "{{.Repository}}:{{.Tag}}" | grep -E 'onlyoffice/documentserver')
          docker save $(docker images --format "{{.Repository}}:{{.Tag}}") | xz --verbose -T0 -z -9e > ${INSTALL_PATH}/docker_images.tar.xz
          cd ${INSTALL_PATH}/docker && tar -czvf ${INSTALL_PATH}/docker.tar.gz --exclude='config/supervisor*' *.yml .env config/

          tar -cvf ${INSTALL_PATH}/offline-docspace.tar \
          -C "${INSTALL_PATH}/OneClickInstall" install-Docker.sh install-Docker-args.sh \
          -C "${INSTALL_PATH}" docker_images.tar.xz docs_images.tar.xz \
          -C "${INSTALL_PATH}" docker.tar.gz
          rm -rf ${INSTALL_PATH}/docker_images.tar.xz ${INSTALL_PATH}/docs_images.tar.xz ${INSTALL_PATH}/docker.tar.gz

          echo "ARTIFACT_NAME=${ARTIFACT_NAME:=4testing-offline-docspace-installation.sh}" >> $GITHUB_ENV
          cat ${INSTALL_PATH}/common/self-extracting.sh ${INSTALL_PATH}/offline-docspace.tar > ${INSTALL_PATH}/${ARTIFACT_NAME}
          chmod +x ${INSTALL_PATH}/${ARTIFACT_NAME}

      - name: Configure AWS Credentials
        if: ${{ success() && github.event.inputs.offline == 'true' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_OCI }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_OCI }}
          aws-region: us-east-1

      - name: Upload 4testing offline self-extracting archive
        if: ${{ success() && github.event.inputs.offline == 'true' }}
        run: |
          aws s3 cp "${{ github.workspace }}/install/${{ env.ARTIFACT_NAME }}" \
            "${{ secrets.AWS_BUCKET_URL_OCI }}/${{ env.ARTIFACT_NAME }}" \
            --acl public-read --content-type application/x-xz --metadata-directive REPLACE

          CF_STATUS=$(aws cloudfront create-invalidation \
            --distribution-id "${{ secrets.AWS_DISTRIBUTION_ID_OCI }}" \
            --paths "/docspace/${{ env.ARTIFACT_NAME }}" \
            --query 'Invalidation.Status' --output text)
          echo "CloudFront invalidation: $CF_STATUS"

          API_STATUS=$(aws apigateway test-invoke-method --rest-api-id ${{ secrets.AWS_REST_API_ID }} --resource-id "${{ secrets.AWS_RESOURCE_ID }}" \
            --http-method PUT --path-with-query-string "/prod/static-site-oo-com" --body "$(jq -c -n '.paths = $ARGS.positional' --args "/docspace/${{ env.ARTIFACT_NAME }}")" \
            --region us-east-1 --query 'status' --output text || :)

          echo "API Gateway test-invoke status: ${API_STATUS:-<failed>}"

  Install-OCI-Docker-Stack-Mode:
    runs-on: ubuntu-22.04
    steps:
      - name: Free Disk Space
        run: |
          sudo docker image prune --all --force
          sudo rm -rf /usr/local/lib/android || true

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Test OCI docker scripts in stack mode
        run: |
          IS_4TESTING="${{ github.event.inputs.testing }}"
          wget https://raw.githubusercontent.com/${{ github.repository }}/${{ github.ref_name }}/install/OneClickInstall/install-Docker.sh
          sed -i "1i set -x" install-Docker.sh && sed -i "/docker-compose.*up -d/ s/$/ --quiet-pull/" install-Docker.sh
          sudo bash install-Docker.sh -skiphc true -noni true -sm true -gb ${{ github.ref_name }} $([ "${IS_4TESTING:-true}" != "false" ] && echo "-s 4testing-") || exit $?

          echo -n "Waiting for all containers to start..."
          timeout 300 bash -c 'while docker ps | grep -q "starting"; do sleep 5; done' && echo "OK" || echo "container_status=timeout" >> $GITHUB_ENV

      - name: Check container status
        run: |
          SERVICES=(dashboards db ds fluent opensearch proxy rabbitmq redis docspace-stack)
          for SERVICE in "${SERVICES[@]}"; do YML_ARGS+=( -f "/app/onlyoffice/${SERVICE}.yml" ); done
          for SVC in $(docker compose "${YML_ARGS[@]}" config --services); do
            docker compose "${YML_ARGS[@]}" ps "$SVC" | grep -q ${SVC} || { echo "::error::$SVC was not created"; MISSING_COUNT=$((MISSING_COUNT+1)); }
          done; [ "${MISSING_COUNT:=0}" -gt 0 ] && { echo "::error::$MISSING_COUNT service(s) were not created."; exit 1; }

          docker ps --all --format "{{.Names}}" | xargs -I {} sh -c '
              status=$(docker inspect --format="{{if .State.Health}}{{.State.Health.Status}}{{else}}no healthcheck{{end}}" {});
              case "$status" in
                healthy) color="\033[0;32m" ;;                                        # green
                "no healthcheck") color="\033[0;33m" ;;                               # yellow
                *) color="\033[0;31m"; echo "container_status=red" >> $GITHUB_ENV ;;  # red
              esac;
              printf "%-50s ${color}%s\033[0m\n" "{}:" "$status";
          '

      - name: Print logs for crashed container
        run: |
          docker ps --all --format "{{.Names}}" | xargs -I {} sh -c '
              status=$(docker inspect --format="{{if .State.Health}}{{.State.Health.Status}}{{else}}no healthcheck{{end}}" {});
              case "$status" in
                healthy | "no healthcheck") ;;
                *)
                  echo "Logs for container {}:";
                  docker logs --tail 30 {} | sed "s/^/\t/g";
                  ;;
              esac;
          '
          case "${{ env.container_status }}" in
              timeout) echo "::error:: Timeout reached. Not all containers are running."; exit 1 ;;
              red) echo "::error:: One or more containers have status 'red'. Job will fail."; exit 1 ;;
          esac
